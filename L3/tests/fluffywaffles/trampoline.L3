// Numbers are still encoded in L3. See test/test10.L3 for a minimal ex.
//-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~
define :main () {
// Let's do some recursion, why not?
//-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~
  //
  // Allocate the world
  //
  // heap size  : 1048576 (1024 * 1024 bytes = 1MB)
  // int64_ts   : 131072 (1MB / 8 bytes = 131,072 int64_t s)
  // # to alloc : 131072 (encoded: * 2 + 1 = 262145)
  //
  // Let's allocate HEAP_MAX 0s and make sure we don't blow the stack
  // doing a recursive insertion-sort. (Which is a no-op, but it doesn't
  // know that.)
  //
  // NOTE: the heap apparently is much bigger than this. Empirical
  // testing suggests it's somewhere between 1025000 and 1050000
  // array-cells (which... should be 8 bytes, right?) large. That
  // seems... Like unless I'm calculating something very wrong, the
  // stack is in fact much, much larger than 1MB using the provided
  // runtime.o, in contrast to the 1MB limit in our runtime.c.
  //
  %size  <- call :encode (1048574) // so... 2 fewer than the max I thought
  %value <- call :encode (0)
  %array <- call allocate (%size, %value) // [ 0 x 131,072 ]
  //
  // Blow the stack
  //
  // call :print_array_range (%array, 0, 131072)

  //
  // Be bouncy & clever
  //
  call :print_array (%array)
  return
}

//-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~
define :array_fill_through (%array, %limit) {
// Fill an array with values from 1 through (including) %limit
//-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~
  %i <- 1 // REMEMBER: the array's 1st element is its *size*, so skip 1
  :initialize_array
  // &array[i] = &array + 8*i
  %i_offset <- %i << 3
  %array_i <- %array + %i_offset
  // Store that value at array_i
  %i_value <- call :encode (%i)
  store %array_i <- %i_value
  // Increment %i
  %i <- %i + 1
  // Loop until we reach the end of the array
  %continue <- %i <= %limit
  br %continue :initialize_array
  return
}

//-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~
define :checked_array_pointer_to (%array, %index) {
// Safely(!) get the address of an element of an array.
// NOTE: Efficiency is traded for safety for no particular reason here.
//-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~
  %index <- %index + 1 // Indices start at 1! Programmers count from 0!
  %size <- call :array_size(%array)
  // Perform bounds check.
  %in_bounds <- %index <= %size
  br %in_bounds :OK_in_bounds
  // :NOK_in_bounds // NOTE this cannot be here; it creates ambiguous L2
    %index_encoded <- call :encode(%index)
    call array-error (%array, %index_encoded) // do not pass go; etc.
  :OK_in_bounds
    %offset <- %index << 3
    %array_i_ptr <- %array + %offset
  return %array_i_ptr
}

//-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~
define :array_swap (%array, %i, %j) {
// Swap 2 elements of an array.
// NOTE: Uses (very) unnecessary amounts of stack space.
//-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~
  // get &a[i], &a[j]
  %array_i_ptr <- call :checked_array_pointer_to(%array, %i)
  %array_j_ptr <- call :checked_array_pointer_to(%array, %j)
  // load a[i], a[j]
  %array_i <- load %array_i_ptr
  %array_j <- load %array_j_ptr
  // swap a[i] â†” a[j]
  store %array_i_ptr <- %array_j
  store %array_j_ptr <- %array_i
  return
}

//-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~
define :checked_array_at (%array, %index) {
// Safely(!) get an element of an array
// NOTE: Efficiency is traded for safety for no particular reason here.
//-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~
  %array_i_ptr <- call :checked_array_pointer_to(%array, %index)
  %array_i <- load %array_i_ptr
  return %array_i
}

//-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~
define :checked_array_set (%array, %index, %value) {
// Safely(!) set an element of an array
// NOTE: %value must be encoded.
// NOTE: Efficiency is traded for safety for no particular reason here.
//-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~
  %array_i_ptr <- call :checked_array_pointer_to(%array, %index)
  store %array_i_ptr <- %value
  return
}

//-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~
define :print_array (%array) {
// Recursively & inefficiently print the whole of an array
//-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~
  %size <- call :array_size (%array)
  %print_array_range <- :print_array_range
  call :trampoline_3 (%array, 0, %size, %print_array_range)
  return
}

//-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~
define :print_array_range (%array, %index, %end) {
// Recursively print a range of values from an array
//-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~
  %index_lt_end <- %index < %end
  br %index_lt_end :OK_index_lt_end
  // :NOK_index_lt_end // NOTE this creates ambiguous L2
    call array-error(%array, %index)
  :OK_index_lt_end
  %array_i <- call :checked_array_at(%array, %index)
  call print (%array_i)
  // Try to recur... NOTE: this SHOULD blow the stack! (Probably.)
  %index <- %index + 1
  // call :print_array_range(%array, %index, %end)
  // return
  // Trampoline version:
  %self <- :print_array_range
  return %self
  // `return :print_array_range` parses as 2 statements:
  // return ; :print_array_range
  // So we have to store the label in a variable first.
}

//-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~
define :trampoline_3 (%arg1, %arg2, %arg3, %function) {
// Make the stack bouncy
//-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~
  :trampoline_jump
  %next <- call %function (%arg1, %arg2, %arg3)
  %returns_self <- %next = %function
  br %returns_self :trampoline_jump
  return
}

//-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~
define :array_size (%array) {
// Get the size of an array
//-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~
  %size <- load %array // get array size (not! encoded)
  return %size
}

//-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~
define :encode (%value) {
// Encode a number in order to pass it into a runtime call.
//-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~
  %result <- %value << 1
  %result <- %result + 1
  return %result
}
