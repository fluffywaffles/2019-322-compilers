// Numbers are still encoded in L3. See test/test10.L3 for a minimal ex.
//-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~
define :main () {
// Let's do some bounds checking, why not?
//-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~
  %size <- 15
  %init <- 0
  %size_encoded <- call :encode (%size)
  %init_encoded <- call :encode (%init)
  %array <- call allocate (%size_encoded, %init_encoded)

  //
  // Initialize %array with 1..15
  //

  call :array_fill_through (%array, 15)
  call print (%array)

  //
  // Test checked_array_at
  //

  %array_4 <- call :checked_array_at(%array, 4)
  call print(%array_4)  // prints: 4
  %array_15 <- call :checked_array_at(%array, 14)
  call print(%array_15) // prints: 15

  //
  // Test checked_array_set
  //

  %value <- call :encode(300)
  call :checked_array_set(%array, 0, %value)
  %value <- call :encode(1337)
  call :checked_array_set(%array, 8, %value)
  call print(%array)

  return
}

//-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~
define :array_fill_through (%array, %limit) {
// Fill an array with values from 1 through (including) %limit
//-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~
  %i <- 1 // REMEMBER: the array's 1st element is its *size*, so skip 1
  :initialize_array
  // &array[i] = &array + 8*i
  %i_offset <- %i << 3
  %array_i <- %array + %i_offset
  // Store that value at array_i
  %i_value <- call :encode (%i)
  store %array_i <- %i_value
  // Increment %i
  %i <- %i + 1
  // Loop until we reach the end of the array
  %continue <- %i <= %limit
  br %continue :initialize_array
  return
}

//-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~
define :checked_array_pointer_to (%array, %index) {
// Safely(!) get the address of an element of an array.
// NOTE: Efficiency is traded for safety for no particular reason here.
//-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~
  %index <- %index + 1 // Indices start at 1! Programmers count from 0!
  %size <- call :array_size(%array)
  // Perform bounds check.
  %in_bounds <- %index <= %size
  br %in_bounds :OK_in_bounds
  // :NOK_in_bounds // NOTE this cannot be here; it creates ambiguous L2
    %index_encoded <- call :encode(%index)
    call array-error (%array, %index_encoded) // do not pass go; etc.
  :OK_in_bounds
    %offset <- %index << 3
    %array_i_ptr <- %array + %offset
  return %array_i_ptr
}

//-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~
define :array_swap (%array, %i, %j) {
// Swap 2 elements of an array.
// NOTE: Uses (very) unnecessary amounts of stack space.
//-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~
  // get &a[i], &a[j]
  %array_i_ptr <- call :checked_array_pointer_to(%array, %i)
  %array_j_ptr <- call :checked_array_pointer_to(%array, %j)
  // load a[i], a[j]
  %array_i <- load %array_i_ptr
  %array_j <- load %array_j_ptr
  // swap a[i] â†” a[j]
  store %array_i_ptr <- %array_j
  store %array_j_ptr <- %array_i
  return
}

//-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~
define :checked_array_at (%array, %index) {
// Safely(!) get an element of an array
// NOTE: Efficiency is traded for safety for no particular reason here.
//-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~
  %array_i_ptr <- call :checked_array_pointer_to(%array, %index)
  %array_i <- load %array_i_ptr
  return %array_i
}

//-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~
define :checked_array_set (%array, %index, %value) {
// Safely(!) set an element of an array
// NOTE: %value must be encoded.
// NOTE: Efficiency is traded for safety for no particular reason here.
//-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~
  %array_i_ptr <- call :checked_array_pointer_to(%array, %index)
  store %array_i_ptr <- %value
  return
}

//-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~
define :print_array (%array) {
// Recursively & inefficiently print the whole of an array
//-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~
  %size <- call :array_size (%array)
  %print_array_range <- :print_array_range
  call :trampoline_3(%array, 0, %size, %print_array_range)
  return
}

//-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~
define :print_array_range (%array, %index, %end) {
// Recursively print a range of values from an array
//-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~
  %index_lt_end <- %index < %end
  br %sindex_lt_end :OK_index_lt_end
  // :NOK_index_lt_end // NOTE this creates ambiguous L2
    call array-error(%array, %index)
  :OK_index_lt_end
  %array_i <- call :checked_array_at(%array, %index)
  call print (%array_i)
  // Try to recur... NOTE: this SHOULD blow the stack! (Probably.)
  // %index <- %index + 1
  // call :print_array_range(%array, %index, %end)
  // return
  // Trampoline version:
  return :print_array_range
}

//-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~
define :trampoline_3 (%arg1, %arg2, %arg3, %function) {
// Make the stack bouncy
//-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~
  :trampoline_jump
  %next <- call %function (%arg1, %arg2, %arg3)
  %returns_self <- %next = %function
  br %returns_self :trampoline_jump
  return
}

//-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~
define :array_size (%array) {
// Get the size of an array
//-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~
  %size <- load %array // get array size (not! encoded)
  return %size
}

//-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~
define :encode (%value) {
// Encode a number in order to pass it into a runtime call.
//-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~
  %result <- %value << 1
  %result <- %result + 1
  return %result
}

//(:entry
//  //-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~
//  (:entry
//  // Fill the heap and try to blow the stack recursing all over it.
//  //-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~
//    0 0
//    //
//    // Allocate space for 1..15
//    //
//    rdi <- 31       // decoded : 15
//    rsi <- 1        // decoded : 0
//    call allocate 2 // rax     : [ 0 x 15 ]
//    rbx <- rax      // save the array for later
//
//    //
//    // Initialize 1..15
//    //
//    mem rax 8   <- 3  // 1
//    mem rax 16  <- 5  // 2
//    mem rax 24  <- 7  // 3
//    mem rax 32  <- 9  // 4
//    mem rax 40  <- 11 // 5
//    mem rax 48  <- 13 // 6
//    mem rax 56  <- 15 // 7
//    mem rax 64  <- 17 // 8
//    mem rax 72  <- 19 // 9
//    mem rax 80  <- 21 // 10
//    mem rax 88  <- 23 // 11
//    mem rax 96  <- 25 // 12
//    mem rax 104 <- 27 // 13
//    mem rax 112 <- 29 // 14
//    mem rax 120 <- 31 // 15
//
//    //
//    // Test checked_array_at
//    //
//    rdi <- rbx
//    rsi <- 4
//    // Exits with an out of bounds message:
//    // rsi <- 15
//    mem rsp -8 <- :got_array_4
//    call :checked_array_at 2
//    :got_array_4
//    rdi <- rax
//    call print 1
//
//    //
//    // Test checked_array_set
//    //
//    rdi <- rbx  // array_ptr
//    rsi <- 4    // index
//    rdx <- 201  // decoded: 100
//    mem rsp -8 <- :set_array_4
//    call :checked_array_set 3
//    :set_array_4
//    // Now print back the array
//    rdi <- rbx
//    call print 1
//
//    return)
//
//  //-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~
//  (:print_array
//  // Recursively & inefficiently print the whole of an array
//  //-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~
//    1 0 // array_ptr
//    mem rsp -8 <- :got_size
//    call :array_size 1
//    :got_size
//    rsi <- 1   // start at 1
//    rdx <- rax // stop at size
//    rcx <- :print_array_range
//    mem rsp -8 <- :exit_print_array
//    call :trampoline_3 4
//    :exit_print_array
//    return)
//
//  //-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~
//  (:print_array_range
//  // Recursively & inefficiently print a range of values from an array
//  //-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~
//    3 3 // array_ptr, start, end (both ends inclusive)
//    cjump rsi < rdx :ok1 // check that we're in-bounds
//    call array-error 2  // if not, fail angrily
//    :ok1
//    mem rsp 0  <- rdi // save array_ptr
//    mem rsp 8  <- rsi // save start
//    mem rsp 16 <- rdx // save end
//    rdi @ rdi rsi 8   // get address of a[i]
//    rdi <- mem rdi 0  // get a[i] from its address
//    call print 1      // print a[i]
//    rdi <- mem rsp 0  // restore array_ptr
//    rsi <- mem rsp 8  // restore start
//    rdx <- mem rsp 16 // restore end
//    rax <- 0          // set rax to 'terminate'
//    rsi++             // increment index
//    cjump rsi = rdx :exit_print_array_range // if we're at the end, quit
//    //*** THIS WILL SEGFAULT... I can't convince it to blow the stack!
//    //*** THIS SHOULD BLOW THE STACK
//    // mem rsp -8 <- :exit_print_array_range
//    // call :print_array_range 3
//    //*** Instead, do this:
//    rax <- :print_array_range // set rax to 'continue'
//    :exit_print_array_range
//    return)
//
//  //-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~
//  (:trampoline_3
//  // Make the stack bouncy
//  // rdi: arg1 rsi: arg2 rdx: arg3 rcx: fn
//  //-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~
//    4 0
//    r12 <- rcx
//    :trampoline_jump
//    mem rsp -8 <- :trampoline_after_call
//    call r12 3    :trampoline_after_call
//    cjump rax = r12 :trampoline_jump
//    return))
